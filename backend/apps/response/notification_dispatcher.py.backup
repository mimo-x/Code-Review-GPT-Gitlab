"""
é€šçŸ¥åˆ†å‘å™¨ - è´Ÿè´£ç®¡ç†å’Œåˆ†å‘åˆ°å„ä¸ªé€šçŸ¥æ¸ é“
"""
import logging
from typing import Dict, Any, List
from django.conf import settings
from datetime import datetime

logger = logging.getLogger(__name__)


class NotificationDispatcher:
    """
    é€šçŸ¥åˆ†å‘å™¨ï¼Œæ”¯æŒå¤šæ¸ é“é€šçŸ¥åˆ†å‘
    """

    def __init__(self, request_id=None):
        self.request_id = request_id

    def dispatch(self, report_data: Dict[str, Any], mr_info: Dict[str, Any]) -> Dict[str, Any]:
        """
        åˆ†å‘é€šçŸ¥åˆ°å„ä¸ªæ¸ é“
        """
        try:
            # è·å–æ‰€æœ‰å¯ç”¨çš„é€šçŸ¥é…ç½®
            notification_configs = self._get_active_notification_configs()

            if not notification_configs:
                logger.warning(f"[{self.request_id}] æœªæ‰¾åˆ°å¯ç”¨çš„é€šçŸ¥é…ç½®")
                return {'success': True, 'channels': [], 'message': 'æ— å¯ç”¨çš„é€šçŸ¥æ¸ é“'}

            logger.info(f"[{self.request_id}] å¼€å§‹åˆ†å‘é€šçŸ¥åˆ° {len(notification_configs)} ä¸ªæ¸ é“")

            results = []
            failed_channels = []

            for config in notification_configs:
                channel_type = config.notification_type
                logger.info(f"[{self.request_id}] å¼€å§‹å‘é€åˆ°æ¸ é“: {channel_type}")

                try:
                    # è°ƒç”¨å¯¹åº”çš„æœåŠ¡å‘é€é€šçŸ¥
                    result = self._send_to_channel(channel_type, config, report_data, mr_info)

                    results.append({
                        'channel': channel_type,
                        'success': result.get('success', False),
                        'message': result.get('message', ''),
                        'response_time': result.get('response_time', 0),
                        'details': result.get('details', {})
                    })

                    if result.get('success', False):
                        logger.info(f"[{self.request_id}] æ¸ é“ {channel_type} å‘é€æˆåŠŸ")
                    else:
                        logger.error(f"[{self.request_id}] æ¸ é“ {channel_type} å‘é€å¤±è´¥: {result.get('message', '')}")
                        failed_channels.append(channel_type)

                except Exception as e:
                    error_msg = f"æ¸ é“ {channel_type} å‘é€å¼‚å¸¸: {str(e)}"
                    logger.error(f"[{self.request_id}] {error_msg}", exc_info=True)
                    failed_channels.append(channel_type)
                    results.append({
                        'channel': channel_type,
                        'success': False,
                        'message': error_msg,
                        'response_time': 0,
                        'details': {'error': str(e)}
                    })

            # æ±‡æ€»ç»“æœ
            success_count = len([r for r in results if r['success']])
            total_count = len(results)

            summary = {
                'success': success_count > 0,  # åªè¦æœ‰ä¸€ä¸ªæˆåŠŸå°±ç®—æ•´ä½“æˆåŠŸ
                'total_channels': total_count,
                'success_channels': success_count,
                'failed_channels': len(failed_channels),
                'failed_channel_list': failed_channels,
                'results': results,
                'dispatch_time': datetime.now().isoformat()
            }

            logger.info(f"[{self.request_id}] é€šçŸ¥åˆ†å‘å®Œæˆ - æˆåŠŸ:{success_count}/{total_count}, å¤±è´¥æ¸ é“:{failed_channels}")

            return summary

        except Exception as e:
            logger.error(f"[{self.request_id}] é€šçŸ¥åˆ†å‘å¼‚å¸¸: {e}", exc_info=True)
            return {
                'success': False,
                'message': f'é€šçŸ¥åˆ†å‘å¤±è´¥: {str(e)}',
                'channels': [],
                'dispatch_time': datetime.now().isoformat()
            }

    def _get_active_notification_configs(self):
        """
        è·å–æ‰€æœ‰å¯ç”¨çš„é€šçŸ¥é…ç½®
        """
        try:
            from apps.llm.models import NotificationConfig
            return NotificationConfig.objects.filter(enabled=True, is_active=True)
        except Exception as e:
            logger.error(f"[{self.request_id}] è·å–é€šçŸ¥é…ç½®å¤±è´¥: {e}", exc_info=True)
            return []

    def _send_to_channel(self, channel_type: str, config, report_data: Dict[str, Any], mr_info: Dict[str, Any]) -> Dict[str, Any]:
        """
        å‘é€é€šçŸ¥åˆ°æŒ‡å®šæ¸ é“
        """
        import time
        start_time = time.time()

        try:
            if channel_type == 'dingtalk':
                return self._send_to_dingtalk(config, report_data, mr_info, start_time)
            elif channel_type == 'gitlab':
                return self._send_to_gitlab(config, report_data, mr_info, start_time)
            elif channel_type == 'slack':
                return self._send_to_slack(config, report_data, mr_info, start_time)
            elif channel_type == 'feishu':
                return self._send_to_feishu(config, report_data, mr_info, start_time)
            elif channel_type == 'wechat':
                return self._send_to_wechat(config, report_data, mr_info, start_time)
            elif channel_type == 'email':
                return self._send_to_email(config, report_data, mr_info, start_time)
            else:
                return {
                    'success': False,
                    'message': f'ä¸æ”¯æŒçš„é€šçŸ¥æ¸ é“: {channel_type}',
                    'response_time': time.time() - start_time
                }

        except Exception as e:
            elapsed_time = time.time() - start_time
            return {
                'success': False,
                'message': f'å‘é€åˆ° {channel_type} å¤±è´¥: {str(e)}',
                'response_time': elapsed_time,
                'details': {'error': str(e)}
            }

    def _send_to_dingtalk(self, config, report_data: Dict[str, Any], mr_info: Dict[str, Any], start_time: float) -> Dict[str, Any]:
        """
        å‘é€åˆ°é’‰é’‰
        """
        try:
            from .services import DingTalkService

            config_dict = config.config_dict
            webhook_url = config_dict.get('webhook_url')
            secret = config_dict.get('secret')

            if not webhook_url:
                return {
                    'success': False,
                    'message': 'é’‰é’‰webhook_urlæœªé…ç½®',
                    'response_time': time.time() - start_time
                }

            # æ„å»ºé’‰é’‰æ¶ˆæ¯
            content = report_data['content']
            mr_title = mr_info.get('title', 'ä»£ç å®¡æŸ¥')
            project_name = mr_info.get('project_name', 'æœªçŸ¥é¡¹ç›®')

            # é™åˆ¶æ¶ˆæ¯é•¿åº¦
            if len(content) > 1500:
                content = content[:1500] + "\n\n...(å†…å®¹è¿‡é•¿å·²æˆªæ–­ï¼Œè¯·æŸ¥çœ‹å®Œæ•´æŠ¥å‘Š)"

            message = f"""### ğŸ¤– AIä»£ç å®¡æŸ¥æŠ¥å‘Š

**é¡¹ç›®**: {project_name}
**MR**: {mr_title}
**æ—¶é—´**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

---
{content}
---
"""

            service = DingTalkService(webhook_url=webhook_url, secret=secret)
            result = service.send_markdown(f"AIä»£ç å®¡æŸ¥æŠ¥å‘Š - {mr_title}", message)

            elapsed_time = time.time() - start_time
            result['response_time'] = elapsed_time

            return result

        except Exception as e:
            elapsed_time = time.time() - start_time
            logger.error(f"[{self.request_id}] é’‰é’‰å‘é€å¤±è´¥: {e}", exc_info=True)
            return {
                'success': False,
                'message': f'é’‰é’‰å‘é€å¤±è´¥: {str(e)}',
                'response_time': elapsed_time
            }

    def _send_to_gitlab(self, config, report_data: Dict[str, Any], mr_info: Dict[str, Any], start_time: float) -> Dict[str, Any]:
        """
        å‘é€åˆ°GitLabï¼ˆMRè¯„è®ºï¼‰
        """
        try:
            from apps.review.services import GitlabService

            project_id = mr_info.get('project_id')
            mr_iid = mr_info.get('mr_iid')

            if not project_id or not mr_iid:
                return {
                    'success': False,
                    'message': 'GitLabé¡¹ç›®IDæˆ–MR IIDç¼ºå¤±',
                    'response_time': time.time() - start_time
                }

            content = report_data['content']

            service = GitlabService()
            result = service.post_mr_comment(project_id, mr_iid, content)

            elapsed_time = time.time() - start_time
            result['response_time'] = elapsed_time

            return result

        except Exception as e:
            elapsed_time = time.time() - start_time
            logger.error(f"[{self.request_id}] GitLabè¯„è®ºå‘é€å¤±è´¥: {e}", exc_info=True)
            return {
                'success': False,
                'message': f'GitLabè¯„è®ºå‘é€å¤±è´¥: {str(e)}',
                'response_time': elapsed_time
            }

    def _send_to_slack(self, config, report_data: Dict[str, Any], mr_info: Dict[str, Any], start_time: float) -> Dict[str, Any]:
        """
        å‘é€åˆ°Slack
        """
        try:
            import requests

            config_dict = config.config_dict
            webhook_url = config_dict.get('webhook_url')

            if not webhook_url:
                return {
                    'success': False,
                    'message': 'Slack webhook_urlæœªé…ç½®',
                    'response_time': time.time() - start_time
                }

            # æ„å»ºSlackæ¶ˆæ¯
            content = report_data['content']
            mr_title = mr_info.get('title', 'ä»£ç å®¡æŸ¥')
            project_name = mr_info.get('project_name', 'æœªçŸ¥é¡¹ç›®')

            # é™åˆ¶æ¶ˆæ¯é•¿åº¦
            if len(content) > 1000:
                content = content[:1000] + "\n\n...(å†…å®¹è¿‡é•¿å·²æˆªæ–­)"

            payload = {
                "text": f"ğŸ¤– AIä»£ç å®¡æŸ¥æŠ¥å‘Š - {mr_title}",
                "blocks": [
                    {
                        "type": "header",
                        "text": {
                            "type": "plain_text",
                            "text": f"ğŸ¤– AIä»£ç å®¡æŸ¥æŠ¥å‘Š"
                        }
                    },
                    {
                        "type": "section",
                        "fields": [
                            {
                                "type": "mrkdwn",
                                "text": f"*é¡¹ç›®:*\n{project_name}"
                            },
                            {
                                "type": "mrkdwn",
                                "text": f"*MR:*\n{mr_title}"
                            },
                            {
                                "type": "mrkdwn",
                                "text": f"*æ—¶é—´:*\n{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
                            }
                        ]
                    },
                    {
                        "type": "divider"
                    },
                    {
                        "type": "section",
                        "text": {
                            "type": "mrkdwn",
                            "text": f"```\n{content}\n```"
                        }
                    }
                ]
            }

            response = requests.post(webhook_url, json=payload, timeout=30)
            elapsed_time = time.time() - start_time

            if response.status_code == 200:
                logger.info(f"[{self.request_id}] Slackå‘é€æˆåŠŸ - è€—æ—¶:{elapsed_time:.2f}ç§’")
                return {
                    'success': True,
                    'message': 'Slackå‘é€æˆåŠŸ',
                    'response_time': elapsed_time,
                    'details': {'status_code': response.status_code}
                }
            else:
                logger.error(f"[{self.request_id}] Slackå‘é€å¤±è´¥ - çŠ¶æ€ç :{response.status_code}, å“åº”:{response.text}")
                return {
                    'success': False,
                    'message': f'Slackå‘é€å¤±è´¥ - HTTP {response.status_code}',
                    'response_time': elapsed_time,
                    'details': {'status_code': response.status_code, 'response': response.text[:200]}
                }

        except Exception as e:
            elapsed_time = time.time() - start_time
            logger.error(f"[{self.request_id}] Slackå‘é€å¼‚å¸¸: {e}", exc_info=True)
            return {
                'success': False,
                'message': f'Slackå‘é€å¼‚å¸¸: {str(e)}',
                'response_time': elapsed_time
            }

    def _send_to_feishu(self, config, report_data: Dict[str, Any], mr_info: Dict[str, Any], start_time: float) -> Dict[str, Any]:
        """
        å‘é€åˆ°é£ä¹¦
        """
        try:
            import requests
            import hashlib
            import base64
            import urllib.parse
            import time

            config_dict = config.config_dict
            webhook_url = config_dict.get('webhook_url')
            secret = config_dict.get('secret')

            if not webhook_url:
                return {
                    'success': False,
                    'message': 'é£ä¹¦webhook_urlæœªé…ç½®',
                    'response_time': time.time() - start_time
                }

            # å¦‚æœé…ç½®äº†ç­¾åï¼Œéœ€è¦æ·»åŠ ç­¾åå‚æ•°
            if secret:
                timestamp = str(int(time.time()))
                string_to_sign = f'{timestamp}\n{secret}'
                hmac_code = hashlib.sha256(string_to_sign.encode('utf-8')).digest()
                sign = urllib.parse.quote_plus(base64.b64encode(hmac_code))
                webhook_url = f"{webhook_url}&timestamp={timestamp}&sign={sign}"

            # æ„å»ºé£ä¹¦æ¶ˆæ¯
            content = report_data['content']
            mr_title = mr_info.get('title', 'ä»£ç å®¡æŸ¥')
            project_name = mr_info.get('project_name', 'æœªçŸ¥é¡¹ç›®')

            # é™åˆ¶æ¶ˆæ¯é•¿åº¦
            if len(content) > 1500:
                content = content[:1500] + "\n\n...(å†…å®¹è¿‡é•¿å·²æˆªæ–­)"

            payload = {
                "msg_type": "interactive",
                "card": {
                    "elements": [
                        {
                            "tag": "div",
                            "text": {
                                "content": f"**é¡¹ç›®**: {project_name}\n**MR**: {mr_title}\n**æ—¶é—´**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
                                "tag": "lark_md"
                            }
                        },
                        {
                            "tag": "div",
                            "text": {
                                "content": content,
                                "tag": "lark_md"
                            }
                        }
                    ],
                    "header": {
                        "title": {
                            "content": "ğŸ¤– AIä»£ç å®¡æŸ¥æŠ¥å‘Š",
                            "tag": "plain_text"
                        },
                        "template": "blue"
                    }
                }
            }

            response = requests.post(webhook_url, json=payload, timeout=30)
            elapsed_time = time.time() - start_time

            if response.status_code == 200:
                result = response.json()
                if result.get('code') == 0:
                    logger.info(f"[{self.request_id}] é£ä¹¦å‘é€æˆåŠŸ - è€—æ—¶:{elapsed_time:.2f}ç§’")
                    return {
                        'success': True,
                        'message': 'é£ä¹¦å‘é€æˆåŠŸ',
                        'response_time': elapsed_time,
                        'details': {'code': result.get('code')}
                    }
                else:
                    logger.error(f"[{self.request_id}] é£ä¹¦å‘é€å¤±è´¥ - é”™è¯¯ç :{result.get('code')}, æ¶ˆæ¯:{result.get('msg')}')
                    return {
                        'success': False,
                        'message': f"é£ä¹¦å‘é€å¤±è´¥ - {result.get('msg', 'æœªçŸ¥é”™è¯¯')}",
                        'response_time': elapsed_time,
                        'details': result
                    }
            else:
                logger.error(f"[{self.request_id}] é£ä¹¦å‘é€å¤±è´¥ - çŠ¶æ€ç :{response.status_code}, å“åº”:{response.text}")
                return {
                    'success': False,
                    'message': f'é£ä¹¦å‘é€å¤±è´¥ - HTTP {response.status_code}',
                    'response_time': elapsed_time,
                    'details': {'status_code': response.status_code, 'response': response.text[:200]}
                }

        except Exception as e:
            elapsed_time = time.time() - start_time
            logger.error(f"[{self.request_id}] é£ä¹¦å‘é€å¼‚å¸¸: {e}", exc_info=True)
            return {
                'success': False,
                'message': f'é£ä¹¦å‘é€å¼‚å¸¸: {str(e)}',
                'response_time': elapsed_time
            }

    def _send_to_wechat(self, config, report_data: Dict[str, Any], mr_info: Dict[str, Any], start_time: float) -> Dict[str, Any]:
        """
        å‘é€åˆ°ä¼ä¸šå¾®ä¿¡
        """
        try:
            import requests

            config_dict = config.config_dict
            webhook_url = config_dict.get('webhook_url')

            if not webhook_url:
                return {
                    'success': False,
                    'message': 'ä¼ä¸šå¾®ä¿¡webhook_urlæœªé…ç½®',
                    'response_time': time.time() - start_time
                }

            # æ„å»ºä¼ä¸šå¾®ä¿¡æ¶ˆæ¯
            content = report_data['content']
            mr_title = mr_info.get('title', 'ä»£ç å®¡æŸ¥')
            project_name = mr_info.get('project_name', 'æœªçŸ¥é¡¹ç›®')

            # é™åˆ¶æ¶ˆæ¯é•¿åº¦
            if len(content) > 1500:
                content = content[:1500] + "\n\n...(å†…å®¹è¿‡é•¿å·²æˆªæ–­)"

            message_content = f"""## ğŸ¤– AIä»£ç å®¡æŸ¥æŠ¥å‘Š

**é¡¹ç›®**: {project_name}
**MR**: {mr_title}
**æ—¶é—´**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

{content}
"""

            payload = {
                "msgtype": "markdown",
                "markdown": {
                    "content": message_content
                }
            }

            response = requests.post(webhook_url, json=payload, timeout=30)
            elapsed_time = time.time() - start_time

            result = response.json()
            if result.get('errcode') == 0:
                logger.info(f"[{self.request_id}] ä¼ä¸šå¾®ä¿¡å‘é€æˆåŠŸ - è€—æ—¶:{elapsed_time:.2f}ç§’")
                return {
                    'success': True,
                    'message': 'ä¼ä¸šå¾®ä¿¡å‘é€æˆåŠŸ',
                    'response_time': elapsed_time,
                    'details': {'errcode': result.get('errcode')}
                }
            else:
                logger.error(f"[{self.request_id}] ä¼ä¸šå¾®ä¿¡å‘é€å¤±è´¥ - é”™è¯¯ç :{result.get("errcode")}, æ¶ˆæ¯:{result.get("errmsg")}')
                return {
                    'success': False,
                    'message': f'ä¼ä¸šå¾®ä¿¡å‘é€å¤±è´¥ - {result.get("errmsg", "æœªçŸ¥é”™è¯¯")}',
                    'response_time': elapsed_time,
                    'details': result
                }

        except Exception as e:
            elapsed_time = time.time() - start_time
            logger.error(f"[{self.request_id}] ä¼ä¸šå¾®ä¿¡å‘é€å¼‚å¸¸: {e}", exc_info=True)
            return {
                'success': False,
                'message': f'ä¼ä¸šå¾®ä¿¡å‘é€å¼‚å¸¸: {str(e)}',
                'response_time': elapsed_time
            }

    def _send_to_email(self, config, report_data: Dict[str, Any], mr_info: Dict[str, Any], start_time: float) -> Dict[str, Any]:
        """
        å‘é€é‚®ä»¶
        """
        try:
            from django.core.mail import send_mail
            from django.conf import settings

            config_dict = config.config_dict
            to_emails = config_dict.get('to', [])
            cc_emails = config_dict.get('cc', [])

            if not to_emails:
                return {
                    'success': False,
                    'message': 'é‚®ä»¶æ”¶ä»¶äººæœªé…ç½®',
                    'response_time': time.time() - start_time
                }

            mr_title = mr_info.get('title', 'ä»£ç å®¡æŸ¥')
            project_name = mr_info.get('project_name', 'æœªçŸ¥é¡¹ç›®')

            subject = f"AIä»£ç å®¡æŸ¥æŠ¥å‘Š - {project_name} - {mr_title}"

            # æ„å»ºé‚®ä»¶å†…å®¹
            html_content = f"""
            <html>
            <body>
                <h2>ğŸ¤– AIä»£ç å®¡æŸ¥æŠ¥å‘Š</h2>
                <p><strong>é¡¹ç›®:</strong> {project_name}</p>
                <p><strong>MR:</strong> {mr_title}</p>
                <p><strong>æ—¶é—´:</strong> {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
                <hr>
                <pre style="white-space: pre-wrap; font-family: monospace;">{report_data['content']}</pre>
                <hr>
                <p><small>æ­¤é‚®ä»¶ç”±AIä»£ç å®¡æŸ¥ç³»ç»Ÿè‡ªåŠ¨å‘é€</small></p>
            </body>
            </html>
            """

            recipient_list = to_emails + cc_emails

            result = send_mail(
                subject=subject,
                message=report_data['content'],  # çº¯æ–‡æœ¬ç‰ˆæœ¬
                from_email=getattr(settings, 'EMAIL_FROM', 'noreply@example.com'),
                recipient_list=recipient_list,
                html_message=html_content,
                fail_silently=False
            )

            elapsed_time = time.time() - start_time

            if result > 0:
                logger.info(f"[{self.request_id}] é‚®ä»¶å‘é€æˆåŠŸ - æ”¶ä»¶äºº:{len(recipient_list)}, è€—æ—¶:{elapsed_time:.2f}ç§’")
                return {
                    'success': True,
                    'message': f'é‚®ä»¶å‘é€æˆåŠŸï¼Œå‘é€ç»™{result}äºº',
                    'response_time': elapsed_time,
                    'details': {'recipient_count': result}
                }
            else:
                logger.error(f"[{self.request_id}] é‚®ä»¶å‘é€å¤±è´¥ - æ— æ”¶ä»¶äºº")
                return {
                    'success': False,
                    'message': 'é‚®ä»¶å‘é€å¤±è´¥',
                    'response_time': elapsed_time
                }

        except Exception as e:
            elapsed_time = time.time() - start_time
            logger.error(f"[{self.request_id}] é‚®ä»¶å‘é€å¼‚å¸¸: {e}", exc_info=True)
            return {
                'success': False,
                'message': f'é‚®ä»¶å‘é€å¼‚å¸¸: {str(e)}',
                'response_time': elapsed_time
            }